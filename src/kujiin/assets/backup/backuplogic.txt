//    class Ambience {
//        private ArrayList<SoundFile> ambiencesoundfiles;
//        private Cut cut;
//        private File ambiencedirectory;
//        private int totalambiencefiles;
//        private double totalduration; // In Seconds
//        AmbienceOption ambienceOption;
//
//        Ambience(Cut cut) {
//            this.cut = cut;
//            ambiencedirectory = new File(Session.directoryambience, cut.name);
//            ambiencesoundfiles = new ArrayList<>();
////        ambienceOption = AmbienceOption.General;
//        }
//
//        public void getambienceinfo() {
//            System.out.println("Getting " + cut.name + "'s Ambience Info");
////        totalduration = 0.0;
//            if (ambiencesoundfiles.size() == 0) {
//                try {
//                    for (File i : ambiencedirectory.listFiles()) {
//                        SoundFile tempsoundfile = new SoundFile(i);
//                        if (tempsoundfile.isvalid()) {
//                            ambiencesoundfiles.add(tempsoundfile);
//                            totalduration += tempsoundfile.getDuration();
//                        }
//                    }
//                } catch (NullPointerException ignored) {
//                }
//                totalambiencefiles = ambiencesoundfiles.size();
//            } //else {totalduration = 0.0;}
//        }
//
//        public ArrayList<SoundFile> getambiencesoundfiles() {
//            return ambiencesoundfiles;
//        }
//
//        public double getTotalduration() {
//            System.out.println(String.format("Returning %d As %s's Total Duration", (int) totalduration, cut.name));
//            return totalduration;
//        }
//
////    public double getTotaldurationinseconds() {
////        double totalduration = 0.0;
////        for (SoundFile i : ambiencesoundfiles) totalduration += i.getDuration();
////        return totalduration;
////    }
//
//        public boolean hasanyAmbience() {
//            try {
//                for (File i : ambiencedirectory.listFiles()) {
//                    if (Tools.supportedaudiofile(i)) {
//                        return true;
//                    }
//                }
//                return false;
//            } catch (NullPointerException e) {
//                return false;
//            }
//        }
//
//        public boolean haslongenoughAmbience(double durationtocheck) {
//            getambienceinfo();
//            return totalduration >= durationtocheck;
//        }
//
//        public void addambiencetoprogram() {
//
//        }
//
//        public void editprogramsambience() {
//
//        }
//
//        public int getTotalambiencefiles() {
//            return totalambiencefiles;
//        }
//
//        public void setTotalambiencefiles(int totalambiencefiles) {
//            this.totalambiencefiles = totalambiencefiles;
//        }
//    }

public class Creator {
//    ArrayList<MediaPlayer> entrainmentplaylist = new ArrayList<>();
//    ArrayList<Cut> cutstoplay = new ArrayList<Cut>();
//    ArrayList<SoundFile> soundFilesforaudiofiles = new ArrayList<>();
//    ArrayList<String> entrainmenttemplist = new ArrayList<>();
//    ArrayList<String> ambiencetemplist = new ArrayList<>();
//    Integer rampduration = 2;
//    Boolean ambienceenabled;
//    CreatingSessionDialog dialog;
//    CreateANewSession createsessiondialog;
//    Session thissession;
//
//    public Creator(Session thissession, ArrayList<Cut> cutstoappendtoplay, Boolean ambienceenabled, CreateANewSession createsessiondialog) {
//        this.thissession = thissession;
//        this.ambienceenabled = ambienceenabled;
//        this.createsessiondialog = createsessiondialog;
//        cutstoplay = cutstoappendtoplay;
//    }
//
//    public void create() {
//        int progressparts = cutstoplay.size();
//        if (ambienceenabled) {
//            progressparts += cutstoplay.size() * 2;
//        }
//        dialog = new CreatingSessionDialog(null, this, progressparts);
//        dialog.show();
//        for (Cut i : cutstoplay) {
//            i.create(ambienceenabled, cutstoplay);
////            EntrainmentThread currentent = new EntrainmentThread(this, i, cutstoplay, 2);
////            currentent.start();
////            if (ambienceenabled) {
////                AmbienceThread currentamb = new AmbienceThread(this, i, "specific");
////                currentamb.start();
//        }
//    }
//
//    public Boolean sessionissuccessfullycreated() {
//        Boolean allfilesexist = true;
//        for (Cut i : cutstoplay) {
//            File entrainmentfile = new File(Session.directorytemp, "Entrainment/" + i.name + ".mp3");
//            File ambiencefile = new File(Session.directorytemp, "Ambience/" + i.name + ".mp3");
//            ;
//            if (!entrainmentfile.exists()) {
//                allfilesexist = false;
//                System.out.println(String.format("%s's Entrainment Doesn't Exist", i.name));
//            }
//            if (ambienceenabled) {
//                if (!ambiencefile.exists()) {
//                    allfilesexist = false;
//                    System.out.println(String.format("%s's Ambience Doesn't Exist", i.name));
//                }
//            }
//        }
//        thissession.setCreated(allfilesexist);
//        return allfilesexist;
//    }
//
//    public void updateprogress() {
//        dialog.updateprogress();
//    }
//
//    public void displaycreatingmessage(String text) {
//        dialog.displaymessage(text);
//    }
//
//    public Boolean sessioniscreated() {
//        boolean sessioncreated = false;
//        if (cutstoplay.size() != 0) {
//            for (Cut i : cutstoplay) {
//                if (i.cutenabled()) {
//                    sessioncreated = i.sessioniscreated(ambienceenabled);
//                }
//            }
//        }
//        return sessioncreated;
//    }
//}
//    class AmbienceThread extends Thread {
//        private Cut currentcut;
//        private File temptextfile;
//        private File tempfile;
//        private File adjustedlengthfile;
//        private File finalfile;
//        private String ambienceoption;
//        private ArrayList<SoundFile> ambiencelist;
//        ArrayList<SoundFile> tempsoundfiles;
//        Creator creator;
//
//        public AmbienceThread(Creator creator, Cut currentcut, String ambienceoption) {
//            this.creator = creator;
//            this.currentcut = currentcut;
//            this.ambienceoption = ambienceoption;
//            temptextfile = new File(Session.directorytemp, "/txt/" + currentcut.name + "Amb.txt");
//            tempfile = new File(Session.directorytemp, "/Ambience/" + currentcut.name + "Temp.mp3");
//            adjustedlengthfile = new File(Session.directorytemp, "/Ambience/" + currentcut.name + "AdjustedLength.mp3");
//            finalfile = new File(Session.directorytemp, "/Ambience/" + this.currentcut.name + ".mp3");
//            tempsoundfiles = currentcut.getambiencesoundfiles();
//        }
//        public void cleanupprevioussession() {
//            if (tempfile.exists()) {tempfile.delete();}
//            if (finalfile.exists()) {finalfile.delete();}
//            if (adjustedlengthfile.exists()) {adjustedlengthfile.delete();}
//            if (temptextfile.exists()) {temptextfile.delete();}
//        }
//
//        @Override
//        public void run() {
//            creator.displaycreatingmessage(String.format("Building %s's Ambience", currentcut.name));
//            cleanupprevioussession();
//            generateambiencelist();
//            generatespecificambience();
//            creator.updateprogress();
//            adjustlength();
//            creator.updateprogress();
////            applyaudiofilters();
////            creator.updateprogress("Done Creating Ambience For " + currentcut.name);
////        cleanupthissession();
//        }
//
//
//        private void generateambiencelist() {
//
//        }
//
//        private void generatespecificambience() {
//
//
//        }
//
//        private void generategeneralambience() {
//
//        }
//
//        private void adjustlength() {
//            // Seconds Are All Fucked Up!
//
//        }
//
//        private void applyaudiofilters() {
//
//        }
//    }
//
//    class EntrainmentThread extends Thread {
//        private File temptextfile;
//        private File tempfile;
//        private File finalfile;
//        private ArrayList<File> entrainmentlist;
//        private ArrayList<Cut> cutstoplay;
//        private int partsforprogressupdates;
//        private Cut currentcut;
//        private int rampduration;
//        private Creator creator;
//
//        public EntrainmentThread(Creator creator, Cut currentcut, ArrayList<Cut> cutstoplay, int rampdurationinminutes) {
//            this.creator = creator;
//            this.currentcut = currentcut;
//            this.cutstoplay = cutstoplay;
//            this.rampduration = rampdurationinminutes;
//            temptextfile = new File(Session.directorytemp, "txt/" + currentcut.name + "Ent.txt");
//            tempfile = new File(Session.directorytemp, "Entrainment/" + currentcut.name + "Temp.mp3");
//            finalfile = new File(Session.directorytemp, "Entrainment/" + this.currentcut.name + ".mp3");
//        }
//
//        @Override
//        public void run() {
//            if (cleanupprevioussession()) {
//                creator.displaycreatingmessage(String.format("Building %s's Entrainment...", currentcut.name));
//                generateentrainmentlist();
//                createentrainment();
////                addaudiofilterstoentrainment();
////                cleanupthissession();
//                creator.updateprogress();
//            } else {System.out.println("Couldn't Delete Previous Session");}
//        }
//
//        private boolean cleanupprevioussession() {
//            try {
//                if (temptextfile.exists()) {FileUtils.forceDelete(temptextfile);}
//                if (tempfile.exists()) {FileUtils.forceDelete(tempfile);}
//                if (finalfile.exists()) {FileUtils.forceDelete(finalfile);}
//            } catch (IOException e) {e.printStackTrace();}
//            boolean allfilesdelete = true;
//            if (tempfile.exists()) {allfilesdelete = false;}
//            if (temptextfile.exists()) {allfilesdelete = false;}
//            if (finalfile.exists()) {allfilesdelete = false;}
//            return allfilesdelete;
//        }
//
//        private void createentrainment() {
//            PrintWriter writer = null;
//            try {
//                writer = new PrintWriter(temptextfile);
//                for (File k : entrainmentlist) {writer.println("file " + "\'" + k.getAbsolutePath() + "\'");}
//                writer.close();
//            } catch (FileNotFoundException ignored) {}
//
////            CommandLine concatenateentrainmentcmdlist = new CommandLine("ffmpeg");
////            concatenateentrainmentcmdlist.addArgument("-f");
////            concatenateentrainmentcmdlist.addArgument("concat");
////            concatenateentrainmentcmdlist.addArgument("-i");
////            concatenateentrainmentcmdlist.addArgument(temptextfile.getAbsolutePath());
////            concatenateentrainmentcmdlist.addArgument("-c");
////            concatenateentrainmentcmdlist.addArgument("copy");
////            concatenateentrainmentcmdlist.addArgument(finalfile.getAbsolutePath());
//////            System.out.println(concatenateentrainmentcmdlist.toString());
////            ByteArrayOutputStream out=new ByteArrayOutputStream();
////            ByteArrayOutputStream err=new ByteArrayOutputStream();
////            DefaultExecutor executor = new DefaultExecutor();
////            PumpStreamHandler handler=new PumpStreamHandler(out,err);
////            executor.setStreamHandler(handler);
////            try {int exitValue = executor.execute(concatenateentrainmentcmdlist);
////            } catch (IOException ignored) {//e.printStackTrace();
////            }
////            if (! tempfile.exists()) {System.out.println(String.format("Couldn't Create %s Entrainment", tempfile.getAbsolutePath()));}
//        }
//
//
//        private void generateentrainmentlist() {
//            entrainmentlist = new ArrayList<>();
//
//        }
//
//        private void addaudiofilterstoentrainment() {
//
//        }
//
//        private void cleanupthissession() {
//            try {
//                FileUtils.forceDelete(temptextfile);
//                FileUtils.forceDelete(tempfile);
//            } catch (IOException ignored) {}
//        }
//    }
}
    public static class EditGoalsDialog extends Stage {
        public TableView<CurrentGoalBinding> CurrentGoalTable;
        public TableColumn<CurrentGoalBinding, Integer> NumberColumn;
        public TableColumn<CurrentGoalBinding, String> GoalTimeColumn;
        public TableColumn<CurrentGoalBinding, String> DueDateColumn;
        public TableColumn<CurrentGoalBinding, String> PercentCompleteColumn;
        public Button CloseButton;
        public TableColumn<CurrentGoalBinding, Boolean> IsCompletedColumn;
        public TableColumn<CurrentGoalBinding, String> CompletionDateColumn;
        public CheckBox ShowCompletedCheckBox;
        public Button AddGoalButton;
        public Button RemoveGoalButton;
        public ChoiceBox<String> CutSelectorComboBox;
        public Button GoalPacingButton;
        private MainController Root;
        private ProgressAndGoalsUI ProgressAndGoals;
        private List<kujiin.xml.Goals.Goal> CurrentGoalList;
        private kujiin.xml.Goals.Goal SelectedGoal;
        private Meditatable SelectedMeditatable;

        public EditGoalsDialog(MainController root, Meditatable meditatable) {
            Root = root;
            SelectedMeditatable = meditatable;
            ProgressAndGoals = Root.getProgressTracker();
            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/DisplayGoals.fxml"));
            fxmlLoader.setController(this);
            try {
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
            setTitle("View/Edit " + meditatable.name + "'s Goals");
            ObservableList<String> allnames = FXCollections.observableArrayList();
            allnames.addAll(Root.getSession().getAllMeditatablesincludingTotalforTracking().stream().map(i -> i.name).collect(Collectors.toList()));
            CutSelectorComboBox.setItems(allnames);
            populatetable();
            CutSelectorComboBox.getSelectionModel().select(SelectedMeditatable.number);
            CutSelectorComboBox.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -> {
                if (newValue.intValue() == -1) {return;}
                if (oldValue != null && goalschanged()) {
                    switch (Util.gui_getyesnocancelconfirmationdialog(Root, "Confirmation", "You Have Made Unsaved Changes To " + SelectedMeditatable.number, "Save These Changes Before Changing Cuts?")) {
                        case YES:
                            savechanges();
                            break;
                        case NO:
                            break;
                        case CANCEL:
                            CutSelectorComboBox.getSelectionModel().select(oldValue.intValue());
                            return;
                    }
                }
                ProgressAndGoals.selectmeditatable(SelectedMeditatable);
                CurrentGoalTable.getItems().clear();
                RemoveGoalButton.setDisable(true);
                GoalPacingButton.setDisable(true);
                populatetable();
            });
            setOnCloseRequest(event -> {
                if (SelectedMeditatable != null && goalschanged()) {
                    switch (Util.gui_getyesnocancelconfirmationdialog(Root, "Confirmation", "Unsaved Changes To " + SelectedMeditatable.name, "Save Before Exiting")) {
                        case YES:
                            savechanges();
                            break;
                        case NO:
                            break;
                        case CANCEL:
                            event.consume();
                    }
                }
            });
        }

        // Getters And Setters

        // Cut Selection Methods
        public boolean goalschanged() {
            try {
                List<kujiin.xml.Goals.Goal> goalsfromxml = SelectedMeditatable.getAllGoals();
                return ! CurrentGoalList.containsAll(goalsfromxml) ||  goalsfromxml.size() != CurrentGoalList.size();
            } catch (NullPointerException ignored) {return false;}
        }

        // Table Methods
        public void populatetable() {
            try {
                ObservableList<CurrentGoalBinding> currentGoals = FXCollections.observableArrayList();
                CurrentGoalList = new ArrayList<>();
                setTitle("View/Edit " + SelectedMeditatable.name + "'s Goals");
                int count = 1;
                for (kujiin.xml.Goals.Goal i : SelectedMeditatable.getAllGoals()) {
                    currentGoals.add(new CurrentGoalBinding(count, Double.toString(i.getGoal_Hours()), i.getDate_Set(),
                            i.getpercentagecompleted(SelectedMeditatable.getTotalMinutesPracticed(false)),
                            i.getCompleted(), i.getDate_Completed()));
                    CurrentGoalList.add(i);
                    count++;
                }
                NumberColumn.setCellValueFactory(cellData -> cellData.getValue().goalid.asObject());
                NumberColumn.setStyle("-fx-alignment: CENTER;");
                GoalTimeColumn.setCellValueFactory(cellData -> cellData.getValue().goalhours);
                GoalTimeColumn.setStyle("-fx-alignment: CENTER;");
                DueDateColumn.setCellValueFactory(cellData -> cellData.getValue().duedate);
                DueDateColumn.setStyle("-fx-alignment: CENTER;");
                PercentCompleteColumn.setCellValueFactory(cellData -> cellData.getValue().percentcomplete);
                PercentCompleteColumn.setStyle("-fx-alignment: CENTER;");
                IsCompletedColumn.setCellValueFactory(cellData -> cellData.getValue().completed);
                IsCompletedColumn.setStyle("-fx-alignment: CENTER;");
                CompletionDateColumn.setCellValueFactory(cellData -> cellData.getValue().datecompleted);
                CompletionDateColumn.setStyle("-fx-alignment: CENTER;");
                CurrentGoalTable.setItems(currentGoals);
            } catch (NullPointerException | IndexOutOfBoundsException ignored) {reset();}
        }
        public void tableselectionchanged(Event event) {
            int index = CurrentGoalTable.getSelectionModel().getSelectedIndex();
            if (index != -1) {SelectedGoal = CurrentGoalList.get(index);}
            RemoveGoalButton.setDisable(index == -1);
            GoalPacingButton.setDisable(index == -1 || SelectedGoal == null || SelectedGoal.getCompleted());
        }
        public void completedgoalstoggle(ActionEvent actionEvent) {
            populatetable();
        }
        public void addgoal(ActionEvent actionEvent) {
            ProgressAndGoals.setnewgoal();
            populatetable();}
        public void removegoal(ActionEvent actionEvent) {
            if (SelectedGoal == null) {return;}
            if (! SelectedGoal.getCompleted() && Util.gui_getokcancelconfirmationdialog(Root, "Confirmation", "Remove This Goal?", "This Cannot Be Undone")) {
                CurrentGoalList.remove(CurrentGoalTable.getSelectionModel().getSelectedIndex());
            }
        }
        public void savechanges() {
            if (SelectedMeditatable != null) {SelectedMeditatable.updateGoals(CurrentGoalList);}
        }

        // Dialog Methods
        public void closeDialog(Event event) {this.close();}
        public void reset() {
            CurrentGoalTable.getItems().clear();
        }

        // Goal pacing
        public void goalpacing(ActionEvent actionEvent) {
            if (SelectedGoal != null && CurrentGoalList != null && SelectedMeditatable != null) {
                new GoalPacingDialog(Root, SelectedMeditatable).showAndWait();
            }
        }

        public void changecutselection(ActionEvent actionEvent) {}

        class CurrentGoalBinding {
            private IntegerProperty goalid;
            private StringProperty goalhours;
            private StringProperty duedate;
            private StringProperty percentcomplete;
            private BooleanProperty completed;
            private StringProperty datecompleted;

            public CurrentGoalBinding(int id, String goalhours, String duedate, String percentcomplete, Boolean completed, String datecompleted) {
                this.goalid = new SimpleIntegerProperty(id);
                this.goalhours = new SimpleStringProperty(Util.format_minstohrsandmins_abbreviated(Util.convertdecimalhourstominutes(new Double(goalhours))));
                this.duedate = new SimpleStringProperty(Util.checkifdateoverdue(duedate));
                this.percentcomplete = new SimpleStringProperty(percentcomplete);
                this.completed = new SimpleBooleanProperty(completed);
                this.datecompleted = new SimpleStringProperty(datecompleted);
            }
        }
    }
    public static class SetANewGoalForSingleCut extends Stage {
        public Label StatusBar;
        public ChoiceBox<String> MeditatableChoiceBox;
        private ProgressAndGoalsUI progressAndGoalsUI;
        public Spinner<Integer> GoalHoursSpinner;
        public Spinner<Integer> GoalMinutesSpinner;
        public Button CancelButton;
        public Button SetGoalButton;
        public Button EditGoalsButton;
        private MainController Root;
        private int practicedminutes;
        private int goalminutes;
        private Meditatable selectedmeditatable;

        public SetANewGoalForSingleCut(MainController root, Meditatable selectedMeditatable) {
            try {
                Root = root;
                progressAndGoalsUI = Root.getProgressTracker();
                selectedmeditatable = selectedMeditatable;
                FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/SetNewGoalDialog.fxml"));
                fxmlLoader.setController(this);
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
            setTitle("Set A New Goal");
            GoalHoursSpinner.setEditable(true);
            GoalMinutesSpinner.setEditable(true);
            MeditatableChoiceBox.getItems().addAll(FXCollections.observableArrayList(Root.getSession().getAllMeditablesincludingTotalNames()));
            MeditatableChoiceBox.setOnAction(event -> meditatableselected());
            GoalHoursSpinner.valueProperty().addListener((observable, oldValue, newValue) -> checkvalue());
            GoalMinutesSpinner.valueProperty().addListener((observable, oldValue, newValue) -> checkvalue());
            Util.custom_spinner_integer(GoalHoursSpinner, 0, Integer.MAX_VALUE, 1, false);
            Util.custom_spinner_integer(GoalMinutesSpinner, 0, 59, 1, false);
            MeditatableChoiceBox.getSelectionModel().select(selectedmeditatable.number);
            meditatableselected();
        }

        // Button Actions
        public void setGoal(Event event) {
            int thisminutes = (GoalHoursSpinner.getValue() * 60) + GoalMinutesSpinner.getValue();
            if (thisminutes <= practicedminutes) {
                Util.gui_showinformationdialog(Root, "Cannot Set Goal", "Goal Time Must Be Higher Than Practiced Time " + Util.format_minstohrsandmins_long(practicedminutes), "Cannot Set Goal");
                return;
            }
            double newhours = Util.convert_hrsandminstodecimalhours(GoalHoursSpinner.getValue(), GoalMinutesSpinner.getValue());
            selectedmeditatable.addGoal(new Goals.Goal(newhours, selectedmeditatable));
            Util.gui_showtimedmessageonlabel(StatusBar, "Success! Goal Of " + newhours + " hrs Added As " + selectedmeditatable.name + "'s Current Goal", 2000);
        }
        public void editgoals(Event event) {
            progressAndGoalsUI.opengoaleditor();
        }

        // Other Methods
        public void meditatableselected() {
            try {
                selectedmeditatable = Root.getSession().getAllMeditatablesincludingTotalforTracking().get(MeditatableChoiceBox.getSelectionModel().getSelectedIndex());
                GoalHoursSpinner.setDisable(false);
                GoalMinutesSpinner.setDisable(false);
            } catch (Exception ignored) {
                try {GoalHoursSpinner.getValueFactory().setValue(0);} catch (NullPointerException e) {}
                GoalHoursSpinner.setDisable(true);
                try {GoalMinutesSpinner.getValueFactory().setValue(0);} catch (NullPointerException e) {}
                GoalMinutesSpinner.setDisable(true);
                return;
            }
            practicedminutes = selectedmeditatable.getTotalMinutesPracticed(false);
            if (selectedmeditatable.getCurrentGoal() == null) {
                goalminutes = practicedminutes;
                int hr = practicedminutes / 60;
                int min = practicedminutes % 60;
                GoalHoursSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(hr, Integer.MAX_VALUE, hr));
                GoalMinutesSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 59, min));
                StatusBar.setText("");
            } else {
                goalminutes = Util.convertdecimalhourstominutes(selectedmeditatable.getCurrentGoal().getGoal_Hours());
                GoalHoursSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(goalminutes / 60, Integer.MAX_VALUE, goalminutes / 60));
                GoalMinutesSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 59, goalminutes % 60));
                StatusBar.setText("Cannot Set A New Goal Until Current Goal Is Completed");
            }
            SetGoalButton.setDisable(selectedmeditatable.getCurrentGoal() != null && ! validvalue());
            GoalMinutesSpinner.setDisable(selectedmeditatable.getCurrentGoal() != null);
            GoalHoursSpinner.setDisable(selectedmeditatable.getCurrentGoal() != null);
            EditGoalsButton.setDisable(selectedmeditatable.getAllGoals() == null);
        }
        public boolean validvalue() {
            return (GoalHoursSpinner.getValue() * 60) + GoalMinutesSpinner.getValue() > practicedminutes;
        }
        public void checkvalue() {
            try {
                int value = (GoalHoursSpinner.getValue() * 60) + GoalMinutesSpinner.getValue();
                if (value < practicedminutes) {
                    GoalHoursSpinner.getValueFactory().setValue(practicedminutes / 60);
                    GoalMinutesSpinner.getValueFactory().setValue(practicedminutes % 60);
                    Util.gui_showtimedmessageonlabel(StatusBar, "Cannot Set Goal Lower Than Practiced Hours", 2000);
                }
            } catch (NullPointerException ignored) {}
        }
    }
    public static class SetANewGoalForMultipleCutsOrElements extends Stage {
        public ToggleButton Presession;
        public ToggleButton RIN;
        public ToggleButton KYO;
        public ToggleButton TOH;
        public ToggleButton SHA;
        public ToggleButton KAI;
        public ToggleButton JIN;
        public ToggleButton RETSU;
        public ToggleButton ZAI;
        public ToggleButton ZEN;
        public ToggleButton Postsession;
        public ToggleButton Earth;
        public ToggleButton Air;
        public ToggleButton Fire;
        public ToggleButton Water;
        public ToggleButton Void;
        public Button SelectAllCutsButton;
        public Button SelectAllElementsButton;
        public Button UnselectAllButton;
        private MainController Root;
        public Spinner<Integer> GoalHoursSpinner;
        public Spinner<Integer> GoalMinutesSpinner;
        public DatePicker GoalDatePicker;
        public Button CancelButton;
        public Button OKButton;
        public Label TopLabel;
        private LocalDate goaldate;
        private Double goalhours;
        private ArrayList<Meditatable> cutsorlementstosetgoalsfor;
        private Integer lowestgoalminutes;

        public SetANewGoalForMultipleCutsOrElements(MainController root, ArrayList<Meditatable> cutsorlementstosetgoalsfor) {
            try {
                Root = root;
                this.cutsorlementstosetgoalsfor = cutsorlementstosetgoalsfor;
                FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/SetMultipleGoalsDialog.fxml"));
                fxmlLoader.setController(this);
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
                setTitle("Set A Goal For Multiple Cuts");
                calculatelowestgoal();
                Presession.setOnAction(event -> calculatelowestgoal());
                RIN.setOnAction(event -> calculatelowestgoal());
                KYO.setOnAction(event -> calculatelowestgoal());
                TOH.setOnAction(event -> calculatelowestgoal());
                SHA.setOnAction(event -> calculatelowestgoal());
                KAI.setOnAction(event -> calculatelowestgoal());
                JIN.setOnAction(event -> calculatelowestgoal());
                RETSU.setOnAction(event -> calculatelowestgoal());
                ZAI.setOnAction(event -> calculatelowestgoal());
                ZEN.setOnAction(event -> calculatelowestgoal());
                Earth.setOnAction(event -> calculatelowestgoal());
                Air.setOnAction(event -> calculatelowestgoal());
                Fire.setOnAction(event -> calculatelowestgoal());
                Water.setOnAction(event -> calculatelowestgoal());
                Void.setOnAction(event -> calculatelowestgoal());
                Postsession.setOnAction(event -> calculatelowestgoal());
                GoalHoursSpinner.setEditable(true);
                GoalHoursSpinner.valueProperty().addListener((observable, oldValue, newValue) -> {
                    int value = (newValue * 60) + GoalMinutesSpinner.getValue();
                    if (newvaluehigherthanmin(value)) {GoalHoursSpinner.getValueFactory().setValue(newValue);}
                    else {GoalHoursSpinner.getValueFactory().setValue(oldValue);}
                });
                Util.custom_spinner_integer(GoalHoursSpinner, 0, Integer.MAX_VALUE, 1, false);
                Util.custom_spinner_integer(GoalMinutesSpinner, 0, 59, 1, true);
                GoalMinutesSpinner.setEditable(true);
                GoalMinutesSpinner.valueProperty().addListener((observable, oldValue, newValue) -> {
                    int value = (GoalHoursSpinner.getValue() * 60) + newValue;
                    if (newvaluehigherthanmin(value)) {GoalMinutesSpinner.getValueFactory().setValue(newValue);}
                    else {GoalMinutesSpinner.getValueFactory().setValue(oldValue);}
                });
                GoalDatePicker.setValue(LocalDate.now());
                for (Meditatable i : cutsorlementstosetgoalsfor) {
                    System.out.println(i.name); select(i.number, true);}
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
        }

        // Getters And Setters
        public LocalDate getGoaldate() {
            return goaldate;
        }
        public void setGoaldate(LocalDate goaldate) {
            this.goaldate = goaldate;
        }
        public Double getGoalhours() {
            return goalhours;
        }
        public void setGoalhours(Double goalhours) {
            this.goalhours = goalhours;
        }
        public boolean isAccepted() {return getGoalhours() != null && getGoaldate() != null && ! getSelectedCutIndexes().isEmpty();}
        public List<Integer> getSelectedCutIndexes() {
            List<Integer> selectedcuts = new ArrayList<>();
            for (int i = 0; i<=10; i++) {if (getselected(i)) {selectedcuts.add(i);}}
            return selectedcuts;
        }
        public void select(int index, boolean value) {
            if (index == 0) {Presession.setSelected(value);}
            if (index == 1) {RIN.setSelected(value);}
            if (index == 2) {KYO.setSelected(value);}
            if (index == 3) {TOH.setSelected(value);}
            if (index == 4) {SHA.setSelected(value);}
            if (index == 5) {KAI.setSelected(value);}
            if (index == 6) {JIN.setSelected(value);}
            if (index == 7) {RETSU.setSelected(value);}
            if (index == 8) {ZAI.setSelected(value);}
            if (index == 9) {ZEN.setSelected(value);}
            if (index == 10) {Earth.setSelected(value);}
            if (index == 11) {Air.setSelected(value);}
            if (index == 12) {Fire.setSelected(value);}
            if (index == 13) {Water.setSelected(value);}
            if (index == 14) {Void.setSelected(value);}
            if (index == 15) {Postsession.setSelected(value);}
        }
        public boolean getselected(int index) {
            if (index == 0) {return Presession.isSelected();}
            if (index == 1) {return RIN.isSelected();}
            if (index == 2) {return KYO.isSelected();}
            if (index == 3) {return TOH.isSelected();}
            if (index == 4) {return SHA.isSelected();}
            if (index == 5) {return KAI.isSelected();}
            if (index == 6) {return JIN.isSelected();}
            if (index == 7) {return RETSU.isSelected();}
            if (index == 8) {return ZAI.isSelected();}
            if (index == 9) {return ZEN.isSelected();}
            if (index == 10) {return ZEN.isSelected();}
            if (index == 11) {return ZEN.isSelected();}
            if (index == 12) {return ZEN.isSelected();}
            if (index == 13) {return ZEN.isSelected();}
            if (index == 14) {return ZEN.isSelected();}
            if (index == 15) {return Postsession.isSelected();}
            return false;
        }

        // Button Actions
        public void Accept(Event event) {
            if (getSelectedCutIndexes().isEmpty()) {
                Util.gui_showinformationdialog(Root, "Information", "Cannot Add Goal", "No Cuts Selected"); return;}
            if (GoalMinutesSpinner.getValue() > 59) {
                Util.gui_showinformationdialog(Root, "Information", "Minutes Cannot Be Greater Than 59", "Select A Value Less Than 59"); return;}
            boolean dategood = GoalDatePicker.getValue().isAfter(LocalDate.now());
            if (dategood) {
                int hours = GoalHoursSpinner.getValue();
                int minutes = GoalMinutesSpinner.getValue();
                double newhours = Util.convert_hrsandminstodecimalhours(hours, minutes);
                setGoalhours(newhours);
                setGoaldate(GoalDatePicker.getValue());
                super.close();
            } else {
                Util.gui_showinformationdialog(Root, "Cannot Set Goal", "Cannot Set Goal", "Due Date Must Be After Today");
                setGoalhours(null);
                setGoaldate(null);
            }
        }
        public void cancelgoalsetting(Event event) {
            this.close();
        }
        public void selectallcuts(ActionEvent actionEvent) {
            for (int i = 1; i < 10; i++) {select(i, true);}
            calculatelowestgoal();
        }
        public void selectallelements(ActionEvent actionEvent) {
            for (int i = 10; i < 15; i++) {select(i, true);}
            calculatelowestgoal();
        }
        public void unselectall(ActionEvent actionEvent) {
            for (int i = 0; i < 16; i++) {
                select(i, false);
            }
            calculatelowestgoal();
        }

        // Utility Methods
        public void calculatelowestgoal() {
            lowestgoalminutes = Root.getProgressTracker().getlowestgoalminutesforallmeditatables(cutsorlementstosetgoalsfor);
            if (lowestgoalminutes > 0) {
                GoalHoursSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(lowestgoalminutes / 60, Integer.MAX_VALUE, lowestgoalminutes / 60));
                GoalMinutesSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 59, lowestgoalminutes % 60));
            } else {
                GoalHoursSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(0, Integer.MAX_VALUE, 0));
                GoalMinutesSpinner.setValueFactory(new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 59, lowestgoalminutes % 60));
            }
        }
        public boolean newvaluehigherthanmin(int newvalue) {
            return lowestgoalminutes == null || lowestgoalminutes == 0 || newvalue > lowestgoalminutes;
        }

    }
    public static class SingleGoalCompletedDialog extends Stage {
        public Label GoalHours;
        public Button CloseButton;
        public Label CurrentHoursLabel;
        public Label TopLabel;
        private MainController Root;

        public SingleGoalCompletedDialog(MainController root, kujiin.xml.Goals.Goal currentGoal, Double currentpracticedhours) {
            Root = root;
            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/GoalCompleted.fxml"));
            fxmlLoader.setController(this);
            try {
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
            setTitle("Goal Achieved");
//            TopLabel.setText(currentGoal.getMeditatableName() + " Goal Achieved");
            GoalHours.setText(currentGoal.getGoal_Hours().toString());
            CurrentHoursLabel.setText("Practiced Hours: " + currentpracticedhours.toString());
            CloseButton.setOnAction(event -> close());
        }
    }
    public static class MultipleGoalsCompletedDialog extends Stage implements Initializable {
        public Label TopLabel;
        public TableView<CompletedGoalsAtEndOfSessionBinding> GoalsCompletedTable;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, String> CutNameColumn;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, String> CurrentHoursColumn;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, String> GoalHoursColumn;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, String> DateSetColumn;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, Integer> DaysTakenColumn;
        public TableColumn<CompletedGoalsAtEndOfSessionBinding, String> DateCompletedColumn;
        public Button CloseButton;
        private MainController Root;

        @Override
        public void initialize(URL location, ResourceBundle resources) {
            CutNameColumn.setCellValueFactory(cellData -> cellData.getValue().cutname);
            GoalHoursColumn.setCellValueFactory(cellData -> cellData.getValue().goalhours);
            DateSetColumn.setCellValueFactory(cellData -> cellData.getValue().dateset);
            DaysTakenColumn.setCellValueFactory(cellData -> cellData.getValue().daysittooktocomplete.asObject());
            DateCompletedColumn.setCellValueFactory(cellData -> cellData.getValue().datecompleted);
            CurrentHoursColumn.setCellValueFactory(cellData -> cellData.getValue().practicedhours);
        }

        public MultipleGoalsCompletedDialog(MainController root, List<kujiin.xml.Goals.Goal> completedgoals) {
            Root = root;
            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/GoalsCompleted.fxml"));
            fxmlLoader.setController(this);
            try {
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
            setTitle(completedgoals.size() + " Goals Achieved");
            TopLabel.setText("You Completed " + completedgoals.size() + " Goals This Session");
            ObservableList<CompletedGoalsAtEndOfSessionBinding> newcompletedgoals = FXCollections.observableArrayList();
            for (kujiin.xml.Goals.Goal i : completedgoals) {
                String cutname = "";
                Meditatable x = Root.getSession().getAllMeditatablesincludingTotalforTracking().get(Root.getSession().getAllMeditablesincludingTotalNames().indexOf(cutname));
                String practicedhours = Double.toString(Util.convert_minstodecimalhours(x.getTotalMinutesPracticed(false), 2));
                String goalhours = i.getGoal_Hours().toString();
                String dateset = i.getDate_Set();
                Integer daystaken = (int) ChronoUnit.DAYS.between(Util.convert_stringtolocaldate(i.getDate_Set()), Util.convert_stringtolocaldate(i.getDate_Due()));
                String datecompleted = i.getDate_Completed();
                newcompletedgoals.add(new CompletedGoalsAtEndOfSessionBinding(cutname, practicedhours, goalhours, dateset, daystaken, datecompleted));
            }
            GoalsCompletedTable.setItems(newcompletedgoals);
            CloseButton.setOnAction(event -> close());
        }
    }
    public static class GoalOverView extends Stage {
        public StackedBarChart<String, Number> GoalBarChart;
        public CategoryAxis CategoryAxis;
        public NumberAxis NumberAxis;
        public Button AddGoalButton;
        public Button EditGoalsButton;
        public Button CloseButton;

        TO DO Set A Limiter So Only 1 Goal Active At A Time. Cannot Set New Goal For (Meditatable) Until Current Goal Is Exceeded
        TO  DO Stacked Bar Chart
        // Series: Current Practiced Time
        // Series: Current Goal
        public GoalOverView(MainController Root) {
            try {
                FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/GoalsOverview.fxml"));
                fxmlLoader.setController(this);
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
                setTitle("Goal Overview");
                XYChart.Series<String, java.lang.Number> currentpracticedseries = new XYChart.Series<>();
                XYChart.Series<String, java.lang.Number> currentgoalseries = new XYChart.Series<>();
                currentpracticedseries.setName("Current Practiced Hours");
                currentgoalseries.setName("Current Goal Hours");
                for (Meditatable i : Root.getSession().getAllMeditatables()) {
                    if (i.getTotalMinutesPracticed(false) > 0) {currentpracticedseries.getData().add(new XYChart.Data<>(i.getNameForChart(), Util.convert_hrsandminstodecimalhours(0, i.getTotalMinutesPracticed(false))));}
                    else {currentpracticedseries.getData().add(new XYChart.Data<>(i.getNameForChart(), 0));}
                    try {currentgoalseries.getData().add(new XYChart.Data<>(i.getNameForChart(), i.getCurrentGoal().getGoal_Hours()));}
                    catch (NullPointerException ignored) {currentgoalseries.getData().add(new XYChart.Data<>(i.getNameForChart(), 0));}
                }
                GoalBarChart.getData().add(currentpracticedseries);
                GoalBarChart.getData().add(currentgoalseries);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
        }

        public void addgoal(ActionEvent actionEvent) {

        }
        public void editgoals(ActionEvent actionEvent) {

        }
    }

    public static class DatePickerDialog extends Stage {
        public Label TopLabel;
        public DatePicker Date;
        public Button AcceptButton;
        public Button CloseButton;
        private LocalDate date;
        private MainController Root;
        private LocalDate MustBeAfterDate;

        public DatePickerDialog(MainController root, String titletext, String TopLabelText, LocalDate minimumdate) {
            Root = root;
            MustBeAfterDate = minimumdate;
            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/DatePickerDialog.fxml"));
            fxmlLoader.setController(this);
            try {
                Scene defaultscene = new Scene(fxmlLoader.load());
                setScene(defaultscene);
                Root.getOptions().setStyle(this);
                this.setResizable(false);
            } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
            setTitle(titletext);
            TopLabel.setText(TopLabelText);
            Date.setValue(LocalDate.now());
        }

        public LocalDate getDate() {
            return date;
        }
        public void setDate(LocalDate date) {
            this.date = date;
        }
        public void accept(ActionEvent actionEvent) {
            if (Date.getValue().isAfter(MustBeAfterDate) || Date.getValue().isEqual(MustBeAfterDate)) {
                setDate(Date.getValue());
                close();
            } else {
                Util.gui_showinformationdialog(Root, "Information", "Goal Date Must Be After " + Util.convert_localdatetostring(MustBeAfterDate), "Select A Later Date");}
        }
        public void cancel(ActionEvent actionEvent) {
            close();
        }
    }
        public static class ReferenceTypeDialog extends Stage {
            private MainController Root;
            public Button AcceptButton;
            public RadioButton HTMLOption;
            public RadioButton TextOption;
            public Button CancelButton;
            public CheckBox FullScreenOption;
            private ReferenceType referenceType;
            private Boolean fullscreen;
            private Boolean enabled;

            public ReferenceTypeDialog (MainController root) {
                Root = root;
                referenceType = Root.getOptions().getSessionOptions().getReferencetype();
                fullscreen = Root.getOptions().getSessionOptions().getReferencefullscreen();
                FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("../assets/fxml/ReferenceTypeDialog.fxml"));
                fxmlLoader.setController(this);
                try {
                    Scene defaultscene = new Scene(fxmlLoader.load());
                    setScene(defaultscene);
                    Root.getOptions().setStyle(this);
                    HTMLOption.setTooltip(new Tooltip("Will Display .html Formatted Text During Each Individual Cut/Element"));
                    TextOption.setTooltip(new Tooltip("Will Display Contents Of Plain Text File During Each Individual Cut/Element"));
                    this.setResizable(false);
                } catch (IOException e) {new MainController.ExceptionDialog(Root, e).showAndWait();}
                setTitle("Reference Type Select");
                if (referenceType != null) {
                    switch (referenceType) {
                        case txt:
                            TextOption.setSelected(true);
                            break;
                        case html:
                            HTMLOption.setSelected(true);
                            break;
                    }
                }
                FullScreenOption.setSelected(fullscreen);
            }

        // Getters And Setters
            public ReferenceType getReferenceType() {
                return referenceType;
            }
            public Boolean getFullscreen() {return fullscreen;}
            public void setFullscreen(Boolean fullscreen) {
                this.fullscreen = fullscreen;
            }
            public Boolean getEnabled() {
                return enabled;
            }
            public void setEnabled(Boolean enabled) {
                this.enabled = enabled;
            }

        // Button Actions
            public void selecthtml(ActionEvent actionEvent) {
                if (HTMLOption.isSelected()) {TextOption.setSelected(false);}
            }
            public void selecttxt(ActionEvent actionEvent) {
                if (TextOption.isSelected()) {HTMLOption.setSelected(false);}
            }
            public void accept(ActionEvent actionEvent) {
                if (HTMLOption.isSelected()) {referenceType = ReferenceType.html;}
                else if (TextOption.isSelected()) {referenceType = ReferenceType.txt;}
                setFullscreen(FullScreenOption.isSelected());
                setEnabled(true);
                this.close();
            }
            public void cancel(ActionEvent actionEvent) {
                setEnabled(false);
                this.close();
            }
        }


        ambience.created_clear();
                Duration currentambienceduration = Duration.ZERO;
                if (ambience.hasEnoughAmbience(getduration())) {
                    for (SoundFile i : ambience.getAmbience()) {
                        if (ambience.gettotalCreatedDuration().lessThan(getduration())) {
                            ambience.created_add(i);
                            currentambienceduration = currentambienceduration.add(new Duration(i.getDuration()));
                        } else {break;}
                    }
                } else {
                    // TODO Creates Some Duplicate Files
                    SoundFile selectedsoundfile;
                    int ambiencecount = 0;
                    int sizetotest;
                    boolean includefile;
                    ambience.created_initialize();
                    while (currentambienceduration.lessThan(getduration())) {
                        try {selectedsoundfile = ambience.getAmbience().get(ambiencecount);}
                        catch (IndexOutOfBoundsException ignored) {ambiencecount = 0; selectedsoundfile = ambience.getAmbience().get(ambiencecount);}
                        ambience.created_add(selectedsoundfile);
                        currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
                        ambiencecount++;
                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
                        if (ambience.getAmbience().size() == 1) {ambience.created_add(ambience.getAmbience().get(0)); currentambienceduration = currentambienceduration.add(new Duration(ambience.getAmbience().get(0).getDuration()));}
                        try {selectedsoundfile = ambience.getAmbience().get(ambiencecount);}
                        catch (IndexOutOfBoundsException ignored) {ambiencecount = 0; selectedsoundfile = ambience.getAmbience().get(ambiencecount);}
                        includefile = true;
                        if (ambience.getCreatedAmbience().size() >= ambience.getAmbience().size()) {sizetotest = (ambience.getAmbience().size() - 1) - ambience.getCreatedAmbience().size() % ambience.getAmbience().size();}
                        else {sizetotest = ambience.getCreatedAmbience().size() - 1;}
                        for (int i = sizetotest; i > 0; i--) {if (ambience.getCreatedAmbience().get(i).equals(selectedsoundfile)) {includefile = false; break;}}
        //                if (includefile && ambience.getCreatedAmbience().size() > 0 && ambience.getCreatedAmbience().get(ambience.getCreatedAmbience().size() - 1).equals(selectedsoundfile)) {includefile = false;}
                        if (includefile) {
                            ambience.created_add(selectedsoundfile);
                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
                        }
                        ambiencecount++;
                    }
                }
        //            else {
        //                Random randint = new Random();
        //                while (currentambienceduration.lessThan(getduration())) {
        //                    List<SoundFile> createdambience = ambience.getCreatedAmbience();
        //                    SoundFile selectedsoundfile = ambience.actual_get(randint.nextInt(ambience.getAmbience().size() - 1));
        //                    if (createdambience.size() < 2) {
        //                        ambience.created_add(selectedsoundfile);
        //                        currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
        //                    } else if (createdambience.size() == 2) {
        //                        if (!selectedsoundfile.equals(createdambience.get(createdambience.size() - 1))) {
        //                            ambience.created_add(selectedsoundfile);
        //                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
        //                        }
        //                    } else if (createdambience.size() == 3) {
        //                        if (!selectedsoundfile.equals(createdambience.get(createdambience.size() - 1)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 2))) {
        //                            ambience.created_add(selectedsoundfile);
        //                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
        //                        }
        //                    } else if (createdambience.size() <= 5) {
        //                        if (!selectedsoundfile.equals(createdambience.get(createdambience.size() - 1)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 2)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 3))) {
        //                            ambience.created_add(selectedsoundfile);
        //                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
        //                        }
        //                    } else if (createdambience.size() > 5) {
        //                        if (!selectedsoundfile.equals(createdambience.get(createdambience.size() - 1)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 2)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 3)) && !selectedsoundfile.equals(createdambience.get(createdambience.size() - 4))) {
        //                            ambience.created_add(selectedsoundfile);
        //                            currentambienceduration = currentambienceduration.add(new Duration(selectedsoundfile.getDuration()));
        //                        }
        //                    }
        //                }
        //            }
        //        int count = 1;
        //        for (SoundFile x : ambience.getCreatedAmbience()) {System.out.println("Ambience " + count + ": " + x.getName()); count++;}
        //        System.out.println("Total Ambience Duration: " + currentambienceduration.toMinutes() + " Minutes");
                return ambience.getCreatedAmbience().size() > 0 && currentambienceduration.greaterThanOrEqualTo(getduration());